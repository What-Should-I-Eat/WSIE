// Generated by CoffeeScript 2.3.2
(function() {
  var EXTENSIONS, _, assert, fs, minimatch, path, statFile,
    indexOf = [].indexOf;

  assert = require('assert');

  fs = require('fs');

  path = require('path');

  _ = require('lodash');

  ({EXTENSIONS} = require('../constants'));

  minimatch = require('minimatch');

  exports.stripLeadingDotOrSlash = function(pathName) {
    return pathName.replace(/^\//, "").replace(/^\.\//, "");
  };

  // Get details about a file.  Returns a fs.Stats object, or null if the file does not exist.
  exports.statFile = statFile = function(file) {
    if (!fs.existsSync(file)) {
      return null;
    }
    return fs.statSync(file);
  };

  // Creates the directory supplied by `dirPath`, creating any intermediate directories as
  // required.  For example, `mkdirs('a/b/c')` might create the directory 'a', then 'a/b', then
  // 'a/b/c'.
  exports.mkdirs = function(dirPath, mode) {
    var currentPath, i, len, pathElement, pathElements, stat;
    // Short-circuit if path already exists
    if (!statFile(dirPath)) {
      pathElements = dirPath.split(path.sep);
      if (_.last(pathElements) === '') {
        pathElements.pop();
      }
      currentPath = "";
      for (i = 0, len = pathElements.length; i < len; i++) {
        pathElement = pathElements[i];
        currentPath += pathElement + path.sep;
        stat = statFile(currentPath);
        if (stat && !stat.isDirectory()) {
          throw new CoverageError(`Can't create directory ${currentPath}: file already exists.`);
        }
        if (!stat) {
          // Create the directory
          fs.mkdirSync(currentPath, mode);
        }
      }
      return true;
    }
    return false;
  };

  // Return the relative path for the file from the basePath.  Returns file name
  // if the file is not relative to basePath.
  exports.getRelativeFilename = function(basePath, fileName) {
    if ((basePath != null) && _.startsWith(fileName, basePath)) {
      fileName = path.relative(basePath, fileName);
    }
    return fileName;
  };

  // Return true if we should exclude a file.

  // `fileName` should be a resolved path (e.g. /users/jwalton/projects/foo/src/blah.coffee)

  exports.excludeFile = function(fileName, options) {
    var basePath, component, components, exclude, excludePath, excluded, i, j, k, len, len1, len2, ref, relativeFilename, resolvedFileName;
    basePath = options.basePath;
    exclude = options.exclude;
    resolvedFileName = path.resolve(fileName);
    assert(resolvedFileName === fileName);
    if (!exclude) {
      return;
    }
    excluded = false;
    if (basePath) {
      relativeFilename = exports.getRelativeFilename(basePath, fileName);
      if (relativeFilename === fileName) {
        // Only instrument files that are inside the project.
        excluded = true;
      }
      // For each exclude value try to use it as a pattern to exclude files
      exclude.map(function(pattern) {
        if (minimatch(relativeFilename, pattern)) {
          return excluded = true;
        }
      });
      components = relativeFilename.split(path.sep);
      for (i = 0, len = components.length; i < len; i++) {
        component = components[i];
        if (indexOf.call(exclude, component) >= 0) {
          excluded = true;
        }
      }
      if (!excluded) {
        for (j = 0, len1 = exclude.length; j < len1; j++) {
          excludePath = exclude[j];
          // Allow `exlude` paths to start with /s or not.
          if (_.startsWith(`/${relativeFilename}`, excludePath) || _.startsWith(relativeFilename, excludePath)) {
            excluded = true;
          }
        }
      }
    }
    if (!excluded && (ref = !path.extname(fileName), indexOf.call(Object.keys(EXTENSIONS), ref) >= 0)) {
      excluded = true;
    }
    if (!excluded) {
      for (k = 0, len2 = exclude.length; k < len2; k++) {
        excludePath = exclude[k];
        if (_.startsWith(fileName, excludePath)) {
          excluded = true;
        }
      }
    }
    return excluded;
  };

  // Takes in a string, and returns a quoted string with any \s and "s in the string escaped to be
  // JS friendly.
  exports.toQuotedString = function(string) {
    var answer;
    answer = string.replace(/\\/g, '\\\\');
    return '"' + (answer.replace(/"/g, '\\\"')) + '"';
  };

}).call(this);
